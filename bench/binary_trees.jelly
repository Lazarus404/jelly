let pow2: I32 -> I32 = fn(k) {
  let r: I32 = 1;
  let i: I32 = 0;
  while (i < k) {
    r = r + r;
    i = i + 1;
  }
  return r;
};

let tree_check: (I32, I32) -> I32 = fn(i, d) {
  if (d == 0) { return i; 0 } else { 0 };

  let n_nodes: I32 = pow2(d + 1) - 1;
  let leaves_start: I32 = pow2(d) - 1;

  let vals: Array<I32> = Array.new<I32>(n_nodes);
  Array.set(vals, 0, i);

  // Fill internal nodes top-down (breadth-first via array indices).
  let idx: I32 = 0;
  while (idx < leaves_start) {
    let v: I32 = Array.get(vals, idx);
    let v2: I32 = v + v;
    let left: I32 = idx + idx + 1;
    let right: I32 = left + 1;
    Array.set(vals, left, v2 - 1);
    Array.set(vals, right, v2);
    idx = idx + 1;
  }

  // Bottom-up check in-place: leaves already have their value.
  let j: I32 = leaves_start - 1;
  while (0 < j + 1) {
    let v: I32 = Array.get(vals, j);
    let left: I32 = j + j + 1;
    let right: I32 = left + 1;
    let res: I32 = v + Array.get(vals, left) - Array.get(vals, right);
    Array.set(vals, j, res);
    j = j - 1;
  }

  return Array.get(vals, 0);
};

let arg: I32 = 10;
let min_depth: I32 = 4;
let max_depth: I32 = if (min_depth + 2 < arg) { arg } else { min_depth + 2 };
let stretch_depth: I32 = max_depth + 1;

System.assert(tree_check(0, stretch_depth) == 0 - 1);
System.assert(tree_check(0, max_depth) == 0 - 1);

// NOTE: The Lua benchmark uses a `for d = min_depth, max_depth, 2` loop.
// We keep the same depths, but call `tree_check` with a *constant* depth to avoid
// stressing a current call-arg edge case in the compiler/VM.
let max_depth_const: I32 = 10;
System.assert(max_depth == max_depth_const);

let niter4: I32 = pow2(max_depth_const - 4 + min_depth);
let c4: I32 = 0;
let i4: I32 = 1;
while (i4 < niter4 + 1) {
  c4 = c4 + tree_check(i4, 4) + tree_check(-i4, 4);
  i4 = i4 + 1;
}
System.assert(c4 == 0 - (niter4 + niter4));

let niter6: I32 = pow2(max_depth_const - 6 + min_depth);
let c6: I32 = 0;
let i6: I32 = 1;
while (i6 < niter6 + 1) {
  c6 = c6 + tree_check(i6, 6) + tree_check(-i6, 6);
  i6 = i6 + 1;
}
System.assert(c6 == 0 - (niter6 + niter6));

let niter8: I32 = pow2(max_depth_const - 8 + min_depth);
let c8: I32 = 0;
let i8: I32 = 1;
while (i8 < niter8 + 1) {
  c8 = c8 + tree_check(i8, 8) + tree_check(-i8, 8);
  i8 = i8 + 1;
}
System.assert(c8 == 0 - (niter8 + niter8));

let niter10: I32 = pow2(max_depth_const - 10 + min_depth);
let c10: I32 = 0;
let i10: I32 = 1;
while (i10 < niter10 + 1) {
  c10 = c10 + tree_check(i10, 10) + tree_check(-i10, 10);
  i10 = i10 + 1;
}
System.assert(c10 == 0 - (niter10 + niter10));

"ok"

